/**
 * Correction Capture Module
 *
 * Detects and stores human corrections to agent decisions.
 * Tracks three types of corrections:
 * 1. Draft edits: When humans modify agent-generated drafts
 * 2. Reclassifications: When humans change the category
 * 3. Escalation overrides: When humans change the escalation level
 *
 * These corrections feed back into the memory system to improve
 * future agent decisions.
 */

import { SupportMemoryService } from '@skillrecordings/memory/support-memory'
import type {
  SupportMemory,
  SupportStage,
} from '@skillrecordings/memory/support-schemas'
import type { MessageCategory, RouteAction } from '../pipeline/types'

// ============================================================================
// Types
// ============================================================================

/**
 * Result of edit distance calculation
 */
export interface EditDistanceResult {
  /** Normalized edit distance (0-1, where 0 = identical, 1 = completely different) */
  distance: number
  /** Number of character operations needed */
  operations: number
  /** Length of the longer string */
  maxLength: number
  /** Whether the edit was meaningful (above threshold) */
  isMeaningful: boolean
}

/**
 * Input for capturing a draft correction
 */
export interface DraftCorrectionInput {
  /** App identifier */
  appId: string
  /** Front conversation ID */
  conversationId: string
  /** Original draft generated by the agent */
  originalDraft: string
  /** Message that was actually sent */
  sentMessage: string
  /** Category of the support request */
  category: MessageCategory
  /** Optional context summary for the memory */
  contextSummary?: string
  /** Optional run ID for tracing */
  runId?: string
  /** Optional customer email */
  customerEmail?: string
  /** Memory IDs that were cited in the original draft */
  citedMemoryIds?: string[]
}

/**
 * Input for capturing a reclassification
 */
export interface ReclassificationInput {
  /** App identifier */
  appId: string
  /** Front conversation ID */
  conversationId: string
  /** Original category assigned by agent */
  originalCategory: MessageCategory
  /** New category assigned by human */
  newCategory: MessageCategory
  /** Original confidence score */
  originalConfidence: number
  /** Reason for reclassification (if provided) */
  reason?: string
  /** Message subject */
  subject?: string
  /** Message body preview */
  bodyPreview?: string
  /** Optional run ID */
  runId?: string
}

/**
 * Input for capturing an escalation override
 */
export interface EscalationOverrideInput {
  /** App identifier */
  appId: string
  /** Front conversation ID */
  conversationId: string
  /** Original routing action from agent */
  originalAction: RouteAction
  /** New routing action from human */
  newAction: RouteAction
  /** Original reason for the routing */
  originalReason: string
  /** Human's reason for override (if provided) */
  overrideReason?: string
  /** Message category */
  category: MessageCategory
  /** Optional run ID */
  runId?: string
}

/**
 * Stored correction record
 */
export interface CorrectionRecord {
  /** Unique ID for the correction */
  id: string
  /** Type of correction */
  type: 'draft_edit' | 'reclassification' | 'escalation_override'
  /** App identifier */
  appId: string
  /** Conversation ID */
  conversationId: string
  /** When the correction was captured */
  capturedAt: string
  /** Severity of the correction (for prioritizing learning) */
  severity: 'minor' | 'moderate' | 'major'
  /** The stored memory record */
  memory: SupportMemory
}

/**
 * Summary of corrections for analytics
 */
export interface CorrectionSummary {
  /** Total corrections captured */
  total: number
  /** Breakdown by type */
  byType: {
    draft_edit: number
    reclassification: number
    escalation_override: number
  }
  /** Breakdown by severity */
  bySeverity: {
    minor: number
    moderate: number
    major: number
  }
  /** Most common original -> corrected patterns */
  patterns: CorrectionPattern[]
}

export interface CorrectionPattern {
  type: string
  original: string
  corrected: string
  count: number
}

// ============================================================================
// Edit Distance Calculation
// ============================================================================

/**
 * Calculate the Levenshtein edit distance between two strings.
 * Uses dynamic programming with space optimization.
 *
 * @param a - First string
 * @param b - Second string
 * @returns Number of operations (insertions, deletions, substitutions)
 */
function levenshteinDistance(a: string, b: string): number {
  const m = a.length
  const n = b.length

  // Edge cases
  if (m === 0) return n
  if (n === 0) return m

  // Use two rows for space efficiency
  let prevRow = new Array(n + 1)
  let currRow = new Array(n + 1)

  // Initialize first row
  for (let j = 0; j <= n; j++) {
    prevRow[j] = j
  }

  // Fill the matrix
  for (let i = 1; i <= m; i++) {
    currRow[0] = i

    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1
      currRow[j] = Math.min(
        prevRow[j] + 1, // deletion
        currRow[j - 1] + 1, // insertion
        prevRow[j - 1] + cost // substitution
      )
    }
    // Swap rows
    ;[prevRow, currRow] = [currRow, prevRow]
  }

  return prevRow[n]
}

/**
 * Calculate normalized edit distance between two strings.
 * Returns a value between 0 (identical) and 1 (completely different).
 *
 * @param original - Original text
 * @param modified - Modified text
 * @param threshold - Threshold for considering edit meaningful (default: 0.1)
 * @returns Edit distance result with normalized distance
 */
export function calculateEditDistance(
  original: string,
  modified: string,
  threshold = 0.1
): EditDistanceResult {
  // Normalize whitespace for comparison
  const normalizedOriginal = normalizeText(original)
  const normalizedModified = normalizeText(modified)

  // Quick check for identical texts
  if (normalizedOriginal === normalizedModified) {
    return {
      distance: 0,
      operations: 0,
      maxLength: Math.max(normalizedOriginal.length, normalizedModified.length),
      isMeaningful: false,
    }
  }

  const operations = levenshteinDistance(normalizedOriginal, normalizedModified)
  const maxLength = Math.max(
    normalizedOriginal.length,
    normalizedModified.length
  )
  const distance = maxLength > 0 ? operations / maxLength : 0

  return {
    distance,
    operations,
    maxLength,
    isMeaningful: distance > threshold,
  }
}

/**
 * Normalize text for comparison (trim, collapse whitespace, lowercase)
 */
function normalizeText(text: string): string {
  return text.trim().replace(/\s+/g, ' ').toLowerCase()
}

/**
 * Classify the severity of a draft edit based on edit distance
 */
function classifyDraftEditSeverity(
  distance: number
): 'minor' | 'moderate' | 'major' {
  if (distance < 0.2) return 'minor'
  if (distance < 0.5) return 'moderate'
  return 'major'
}

// ============================================================================
// Correction Capture Functions
// ============================================================================

/**
 * Capture a draft correction when a human edits an agent-generated draft.
 *
 * @param input - Draft correction details
 * @returns Correction record if meaningful edit, null if trivial/no edit
 *
 * @example
 * ```typescript
 * const correction = await captureDraftCorrection({
 *   appId: 'total-typescript',
 *   conversationId: 'cnv_123',
 *   originalDraft: 'Here is the refund...',
 *   sentMessage: 'Your refund has been processed...',
 *   category: 'support_refund',
 * })
 *
 * if (correction) {
 *   console.log(`Captured ${correction.severity} draft edit`)
 * }
 * ```
 */
export async function captureDraftCorrection(
  input: DraftCorrectionInput
): Promise<CorrectionRecord | null> {
  const {
    appId,
    conversationId,
    originalDraft,
    sentMessage,
    category,
    contextSummary,
    runId,
    citedMemoryIds,
  } = input

  // Calculate edit distance
  const editResult = calculateEditDistance(originalDraft, sentMessage)

  // Skip trivial edits (< 10% different)
  if (!editResult.isMeaningful) {
    return null
  }

  const severity = classifyDraftEditSeverity(editResult.distance)
  const now = new Date().toISOString()

  // Build situation description
  const situation = buildDraftCorrectionSituation(
    category,
    editResult.distance,
    contextSummary
  )

  // Store the correction memory
  const memory = await SupportMemoryService.store({
    app_slug: appId,
    situation,
    decision: `Original draft: ${truncate(originalDraft, 500)}`,
    stage: 'draft' as SupportStage,
    outcome: 'corrected',
    correction: `Human edited to: ${truncate(sentMessage, 500)}`,
    category,
    conversation_id: conversationId,
    tags: ['correction', 'draft_edit', severity],
  })

  // Record failure outcome for cited memories
  if (runId && citedMemoryIds && citedMemoryIds.length > 0) {
    try {
      const { recordCitationOutcome } = await import('./query')
      await recordCitationOutcome(citedMemoryIds, runId, 'failure', appId)
    } catch (error) {
      console.warn(
        '[captureDraftCorrection] Failed to record citation outcomes:',
        error
      )
    }
  }

  return {
    id: memory.id,
    type: 'draft_edit',
    appId,
    conversationId,
    capturedAt: now,
    severity,
    memory,
  }
}

/**
 * Capture a reclassification when a human changes the category.
 *
 * @param input - Reclassification details
 * @returns Correction record
 *
 * @example
 * ```typescript
 * await captureReclassification({
 *   appId: 'total-typescript',
 *   conversationId: 'cnv_123',
 *   originalCategory: 'support_technical',
 *   newCategory: 'support_refund',
 *   originalConfidence: 0.85,
 *   reason: 'Customer is actually asking for refund',
 * })
 * ```
 */
export async function captureReclassification(
  input: ReclassificationInput
): Promise<CorrectionRecord> {
  const {
    appId,
    conversationId,
    originalCategory,
    newCategory,
    originalConfidence,
    reason,
    subject,
    bodyPreview,
    runId,
  } = input

  const now = new Date().toISOString()

  // Determine severity based on how wrong the classification was
  const severity = classifyReclassificationSeverity(
    originalCategory,
    newCategory,
    originalConfidence
  )

  // Build situation description
  const situation = buildReclassificationSituation(
    originalCategory,
    originalConfidence,
    subject,
    bodyPreview
  )

  // Store the correction memory
  const memory = await SupportMemoryService.store({
    app_slug: appId,
    situation,
    decision: `Classified as: ${originalCategory} (confidence: ${(originalConfidence * 100).toFixed(0)}%)`,
    stage: 'classify' as SupportStage,
    outcome: 'corrected',
    correction: `Reclassified to: ${newCategory}${reason ? ` - Reason: ${reason}` : ''}`,
    category: newCategory,
    conversation_id: conversationId,
    tags: ['correction', 'reclassification', severity],
  })

  return {
    id: memory.id,
    type: 'reclassification',
    appId,
    conversationId,
    capturedAt: now,
    severity,
    memory,
  }
}

/**
 * Capture an escalation override when a human changes the routing.
 *
 * @param input - Escalation override details
 * @returns Correction record
 *
 * @example
 * ```typescript
 * await captureEscalationOverride({
 *   appId: 'total-typescript',
 *   conversationId: 'cnv_123',
 *   originalAction: 'respond',
 *   newAction: 'escalate_urgent',
 *   originalReason: 'Standard refund request',
 *   overrideReason: 'Customer threatening chargeback',
 *   category: 'support_refund',
 * })
 * ```
 */
export async function captureEscalationOverride(
  input: EscalationOverrideInput
): Promise<CorrectionRecord> {
  const {
    appId,
    conversationId,
    originalAction,
    newAction,
    originalReason,
    overrideReason,
    category,
    runId,
  } = input

  const now = new Date().toISOString()

  // Determine severity based on the direction and magnitude of the override
  const severity = classifyEscalationOverrideSeverity(originalAction, newAction)

  // Build situation description
  const situation = `Category: ${category}\nOriginal routing: ${originalAction}\nReason: ${originalReason}`

  // Store the correction memory
  const memory = await SupportMemoryService.store({
    app_slug: appId,
    situation,
    decision: `Routed to: ${originalAction} - ${originalReason}`,
    stage: 'route' as SupportStage,
    outcome: 'corrected',
    correction: `Override to: ${newAction}${overrideReason ? ` - ${overrideReason}` : ''}`,
    category,
    conversation_id: conversationId,
    tags: ['correction', 'escalation_override', severity],
  })

  return {
    id: memory.id,
    type: 'escalation_override',
    appId,
    conversationId,
    capturedAt: now,
    severity,
    memory,
  }
}

// ============================================================================
// Batch Operations
// ============================================================================

/**
 * Compare a stored draft with the sent message to detect corrections.
 * Use this when processing outbound message webhooks.
 *
 * @param params - Comparison parameters
 * @returns Whether a correction was detected and captured
 */
export async function compareAndCaptureDraftCorrection(params: {
  appId: string
  conversationId: string
  storedDraft: string | null
  sentMessage: string
  category: MessageCategory
  contextSummary?: string
  runId?: string
  citedMemoryIds?: string[]
}): Promise<{ captured: boolean; correction?: CorrectionRecord }> {
  const { storedDraft, sentMessage, ...rest } = params

  // If no stored draft, we can't compare
  if (!storedDraft) {
    return { captured: false }
  }

  const correction = await captureDraftCorrection({
    ...rest,
    originalDraft: storedDraft,
    sentMessage,
  })

  if (correction) {
    return { captured: true, correction }
  }

  // Draft was used without meaningful edits - record success
  try {
    const { storeDraftSuccess } = await import('../pipeline/steps/draft')
    await storeDraftSuccess({
      appId: rest.appId,
      draft: storedDraft,
      category: rest.category,
      conversationId: rest.conversationId,
      contextSummary: rest.contextSummary || '',
      runId: rest.runId,
      citedMemoryIds: rest.citedMemoryIds,
    })
  } catch (error) {
    console.warn(
      '[compareAndCaptureDraftCorrection] Failed to store success:',
      error
    )
  }

  return { captured: false }
}

// ============================================================================
// Helper Functions
// ============================================================================

function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text
  return text.slice(0, maxLength - 3) + '...'
}

function buildDraftCorrectionSituation(
  category: MessageCategory,
  editDistance: number,
  contextSummary?: string
): string {
  const parts = [
    `Category: ${category}`,
    `Edit magnitude: ${(editDistance * 100).toFixed(0)}%`,
  ]

  if (contextSummary) {
    parts.push(`Context: ${contextSummary}`)
  }

  return parts.join('\n')
}

function buildReclassificationSituation(
  originalCategory: MessageCategory,
  confidence: number,
  subject?: string,
  bodyPreview?: string
): string {
  const parts = [
    `Original classification: ${originalCategory}`,
    `Agent confidence: ${(confidence * 100).toFixed(0)}%`,
  ]

  if (subject) {
    parts.push(`Subject: ${subject}`)
  }

  if (bodyPreview) {
    parts.push(`Preview: ${truncate(bodyPreview, 200)}`)
  }

  return parts.join('\n')
}

function classifyReclassificationSeverity(
  original: MessageCategory,
  corrected: MessageCategory,
  confidence: number
): 'minor' | 'moderate' | 'major' {
  // High confidence wrong = major problem
  if (confidence > 0.8) return 'major'

  // Category families - some misclassifications are worse than others
  const supportCategories = new Set([
    'support_access',
    'support_refund',
    'support_transfer',
    'support_technical',
    'support_billing',
  ])

  const escalationCategories = new Set(['fan_mail', 'instructor_strategy'])

  const skipCategories = new Set(['spam', 'system', 'resolved'])

  // Misclassifying something that should be skipped = minor
  if (skipCategories.has(original) && skipCategories.has(corrected)) {
    return 'minor'
  }

  // Missing something that needs response = major
  if (skipCategories.has(original) && !skipCategories.has(corrected)) {
    return 'major'
  }

  // Responding to something that should be skipped = moderate
  if (!skipCategories.has(original) && skipCategories.has(corrected)) {
    return 'moderate'
  }

  // Same family = minor
  if (
    (supportCategories.has(original) && supportCategories.has(corrected)) ||
    (escalationCategories.has(original) && escalationCategories.has(corrected))
  ) {
    return 'minor'
  }

  return 'moderate'
}

function classifyEscalationOverrideSeverity(
  original: RouteAction,
  corrected: RouteAction
): 'minor' | 'moderate' | 'major' {
  const escalationLevels: Record<RouteAction, number> = {
    silence: 0,
    respond: 1,
    support_teammate: 2,
    catalog_voc: 2,
    escalate_human: 3,
    escalate_instructor: 4,
    escalate_urgent: 5,
  }

  const originalLevel = escalationLevels[original] ?? 1
  const correctedLevel = escalationLevels[corrected] ?? 1
  const diff = Math.abs(correctedLevel - originalLevel)

  // Under-escalating (missed urgency) is worse than over-escalating
  const isUnderEscalation = correctedLevel > originalLevel

  if (diff >= 3) return 'major'
  if (diff >= 2 && isUnderEscalation) return 'major'
  if (diff >= 2) return 'moderate'
  if (diff >= 1) return 'minor'

  return 'minor'
}

// ============================================================================
// Export for Testing
// ============================================================================

export const _internal = {
  levenshteinDistance,
  normalizeText,
  classifyDraftEditSeverity,
  classifyReclassificationSeverity,
  classifyEscalationOverrideSeverity,
  truncate,
}
